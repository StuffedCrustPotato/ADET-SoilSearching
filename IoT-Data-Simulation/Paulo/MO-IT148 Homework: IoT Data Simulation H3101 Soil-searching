import pandas as pd
import numpy as np
from datetime import datetime, timedelta

# --- Configuration ---
num_records = 20  # Adjust this number as needed for your simulation
# --- End Configuration ---

# Example for Smart Environmental Monitoring - Matching groupmate's structure
data = []

for i in range(num_records):
    # Generate random timestamp
    timestamp = datetime.now() - timedelta(minutes=np.random.randint(0, 1440))

    # Generate a unique/random sensor ID (keep this as it's good practice,
    # although your groupmate's output didn't explicitly show it as a column name,
    # it would be needed in a real system to identify readings)
    sensor_id = f"ENV-SENSOR-{np.random.randint(1000, 9999)}"

    # Simulate environmental data with plausible ranges - Matching groupmate's columns
    temperature_c = round(np.random.uniform(10.0, 40.0), 1)  # Temperature in Celsius
    humidity_percent = np.random.randint(20, 90)          # Humidity in percentage
    co2_ppm = np.random.randint(400, 2000)                # CO2 level in parts per million
    pm25_ug_m3 = round(np.random.uniform(5.0, 75.0), 1)   # PM2.5 in µg/m³ (e.g., 5-15 Good, 15-40 Moderate, 40-65 Unhealthy)
    soil_moisture_percent = np.random.randint(10, 80)    # Soil Moisture in percentage
    ph = round(np.random.uniform(5.5, 8.5), 1)           # pH (e.g., 5.5-7.0 slightly acidic, 7.0 neutral, 7.0-8.5 slightly alkaline)
    turbidity_ntu = round(np.random.uniform(1.0, 50.0), 1)# Turbidity in NTU (e.g., <5 typically good drinking water, higher indicates more suspended solids)
    # Assuming 'Contamination' is a generic pollutant level, perhaps 0-100 scale
    contamination_ppm = round(np.random.uniform(0.0, 10.0), 2) # Example contaminant level

    record = {
        # Note: Column names might need exact matching with groupmate's later if combining data
        # Using descriptive names for now, you might adjust based on your group's final decision
        "Timestamp": timestamp,
        "Sensor_ID": sensor_id, # Added sensor ID for realism, group can decide if needed in final CSV
        "Temperature (°C)": temperature_c,
        "Humidity (%)": humidity_percent,
        "CO2 (ppm)": co2_ppm,
        "PM2.5 (µg/m³)": pm25_ug_m3,
        "Soil Moisture (%)": soil_moisture_percent,
        "pH": ph,
        "Turbidity (NTU)": turbidity_ntu,
        "Contamination (ppm)": contamination_ppm
    }
    data.append(record)

# Convert to DataFrame
df = pd.DataFrame(data)

# Sort by timestamp (optional, but good for time-series)
df = df.sort_values(by="Timestamp").reset_index(drop=True)

# Save dataset
csv_filename = "environmental_data_group_consistent.csv" # Use a name indicating group agreement
json_filename = "environmental_data_group_consistent.json" # Optional

df.to_csv(csv_filename, index=False)
df.to_json(json_filename, orient="records", indent=4)

# Display first few rows and info to confirm
print("Generated Group-Consistent Data Head:")
print(df.head())

print("\nDataFrame Info:")
df.info()

print(f"\nSuccessfully generated {num_records} records with group-consistent parameters.")
print(f"Data saved to {csv_filename} and {json_filename}.")
